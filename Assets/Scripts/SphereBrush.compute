#pragma kernel SphereBrush
static const int numThreads = 8;

RWStructuredBuffer<float> points;

int numPointsPerAxis;
int numVoxelPerAxis;
int sphereBrushPointSize;
int3 brushRelativePosition;
//float3 brushPosition;
float brushValue;
float boundsSize;
int3 chunkPosition;

//brushRelativePosition = worldToPoint(brushWorldPosition);

float invLerp(float from, float to, float value) {
    return value - from;
}

float CubicLength(int x, int y, int z)
{
    return sqrt((x * x) + (y * y) + (z * z));
}

float3 pointToWorld(int3 pointPos)
{
    return (float3(invLerp(0.0, numVoxelPerAxis, pointPos.x) - 0.5f, invLerp(0.0, numVoxelPerAxis, pointPos.y) - 0.5f, invLerp(0.0, numVoxelPerAxis, pointPos.z) - 0.5f) * boundsSize) + ((float3)chunkPosition * boundsSize);
}

int3 worldToPoint(float3 worldPos)
{
    float3 relativePos = (worldPos - ((float3)chunkPosition * boundsSize)) / boundsSize;

    int3 pointPos = int3(round(lerp(0.0, numVoxelPerAxis, relativePos.x + 0.5)), round(lerp(0.0, numVoxelPerAxis, relativePos.y + 0.5)), round(lerp(0.0, numVoxelPerAxis, relativePos.z + 0.5)));

    return pointPos;
}

int indexFromCoord(uint x, uint y, uint z) {
    return (z * numPointsPerAxis * numPointsPerAxis) + (y * numPointsPerAxis) + x;
}


float GetSphereBrushValueAtPoint(int3 pos)
{
    return clamp((sphereBrushPointSize * sphereBrushPointSize) - CubicLength(pos.x, pos.y, pos.z), 0.0, sphereBrushPointSize * 2.0);
    //return sphereBrushPointSize - CubicLength(pos.x, pos.y, pos.z);
}


[numthreads(numThreads, numThreads, numThreads)]
void SphereBrush(int3 id : SV_DispatchThreadID)
{
    if (id.x >= numPointsPerAxis || id.y >= numPointsPerAxis || id.z >= numPointsPerAxis) {
        return;
    }

    //int3 brushRelativePosition = worldToPoint(brushPosition) - id;

    //float3 worldPoint = pointToWorld(relativePoint) * (boundsSize / (numPointsPerAxis - 1));



    // * (boundsSize / (numPointsPerAxis - 1))

    //float brushSample = GetSphereBrushValueAtPoint(relativePoint.x - id.x, relativePoint.x - id.y, relativePoint.x - id.z);
    float brushSample = GetSphereBrushValueAtPoint(id - relativePoint.x);
    

    points[indexFromCoord(id.x, id.y, id.z)] = (brushSample * brushSample * brushValue);
    //points[indexFromCoord(id.x, id.y, id.z)] += 0.1f;

    //var samplePoint = brushPosition + (new Vector3(x - sphereBrushPointSize, y - sphereBrushPointSize, z - sphereBrushPointSize) / boundsSize);
}

/*#include "Assets/Includes/Density.cginc"
#include "Assets/Includes/Noise.cginc"



// Noise settings
StructuredBuffer<float3> offsets;
int octaves;
float lacunarity;
float persistence;
float noiseScale;
float noiseWeight;
float floorOffset;
float weightMultiplier;
bool closeEdges;
float hardFloor;
float hardFloorWeight;

float4 params;

[numthreads(numThreads, numThreads, numThreads)]
void Density(int3 id : SV_DispatchThreadID)
{
    if (id.x >= numPointsPerAxis || id.y >= numPointsPerAxis || id.z >= numPointsPerAxis) {
        return;
    }

    float3 pos = centre + id * spacing - boundsSize / 2;
    float offsetNoise = 0;

    float noise = 0;

    float frequency = noiseScale / 100;
    float amplitude = 1;
    float weight = 1;
    for (int j = 0; j < octaves; j++) {
        float n = snoise((pos + offsetNoise) * frequency + offsets[j] + offset);
        float v = 1 - abs(n);
        v = v * v;
        v *= weight;
        weight = max(min(v * weightMultiplier, 1), 0);
        noise += v * amplitude;
        amplitude *= persistence;
        frequency *= lacunarity;
    }

    float finalVal = -(pos.y + floorOffset) + noise * noiseWeight + (pos.y % params.x) * params.y;

    if (pos.y < hardFloor) {
        finalVal += hardFloorWeight;
    }

    if (closeEdges) {
        float3 edgeOffset = abs(pos * 2) - worldSize + spacing / 2;
        float edgeWeight = saturate(sign(max(max(edgeOffset.x, edgeOffset.y), edgeOffset.z)));
        finalVal = finalVal * (1 - edgeWeight) - 100 * edgeWeight;

    }

    int index = indexFromCoord(id.x, id.y, id.z);
    points[index] = finalVal;
}*/
